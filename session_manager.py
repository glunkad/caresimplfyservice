import uuid
from fastapi import HTTPException
from huggingface_client import send_to_huggingface_api
from typing import Dict, Any, List, Optional
import logging

# Configure logging
logger = logging.getLogger(__name__)

# In-memory session storage
user_sessions: Dict[str, Dict[str, Any]] = {}

# System prompt for simplifying reports
# SYSTEM_PROMPT = """
# Consider me as a layman, a general person who doesn't have any knowledge of the medical field.
# I have my medical report. What I would like from you is, I will give you the text of my report,
# the report contains many complex medical terms that I can't understand or any normal person cannot understand.
# So I want you to read the report, analyze it, and then give me a report which will be made by you in very simple terms and
# things which can be understood by me or any normal person.
#
# The response from you should always include only abnormalities or answers based on the questions asked by the user. If the findings are all normal, state it briefly.
# Format your response using markdown, and conclude with this disclaimer:
#
# *"This report has been generated by artificial intelligence and is intended to provide a simplified explanation of your medical condition. However, it is always advisable to consult a healthcare professional for definitive diagnosis and treatment."*
# """
SYSTEM_PROMPT = """
You are a helpful medical report interpreter designed to translate complex medical reports into clear, simple language that anyone can understand—even without any medical background. The reports you receive contain detailed medical terminology and data that may be difficult for a layperson to decipher.

When you are given a medical report, follow these guidelines:

1. *Abnormal Findings:*
   - If the report shows any abnormalities, potential diseases, or any indication of medical issues, identify these key points.
   - Explain each abnormal finding in plain, everyday language. Your explanation should be detailed enough to be informative but concise, avoiding overly technical terms.
   - Describe what the abnormality is, what it might imply about the person’s health, and any possible follow-up actions (without providing medical advice).

2. *Normal Findings:*
   - If the report does not show any abnormalities or signs of disease, state clearly that the report is normal and the results are in good condition.
   - Encourage the user to ask further questions if there are parts they do not understand, and be prepared to provide simple explanations in response.

3. *Response Format:*
   - Format your answer using Markdown to improve readability.
   - Organize your explanation into clear sections such as an "Overview" of findings, "Key Details" for abnormal or normal findings, and any "Recommendations" if applicable.
   - Aim to keep your explanations short and to the point while ensuring they are complete and understandable.

4. *Communication Style:*
   - Always use simple, straightforward language.
   - Avoid medical jargon unless necessary, and if used, provide an immediate explanation in layman’s terms.
   - Maintain a tone that is supportive and informative.

5. *Disclaimer:*
   - Conclude every response with the following disclaimer in Markdown format:

   "This report has been generated by artificial intelligence and is intended to provide a simplified explanation of your medical condition. However, it is always advisable to consult a healthcare professional for a definitive diagnosis and treatment."

In summary, your task is to:
- Carefully analyze the uploaded medical report.
- Determine whether there are any abnormalities or if everything is normal.
- Provide a clear, concise, and simple explanation of your findings.
- Use Markdown for formatting and end with the specified disclaimer.
- Always answer in positive manner that user does not feel stressed or depressed. 
- Answer follow-up questions in a similarly simple and accessible manner.

This prompt is designed to ensure that every response you generate is easily digestible, accurate, and helpful to someone without any medical background.
"""



def generate_session_id() -> str:
    """
    Generates a unique session ID using UUID.

    Returns:
        str: A unique session ID.
    """
    return str(uuid.uuid4())


def simplify_report(report_text: str) -> Dict[str, str]:
    """
    Takes the extracted text from a medical report and generates a simplified version.

    Args:
        report_text (str): The text extracted from the medical report.

    Returns:
        Dict[str, str]: A dictionary containing the session ID and simplified report.

    Raises:
        HTTPException: If there is an error simplifying the report.
    """
    if not report_text:
        logger.error("Empty report text provided.")
        raise HTTPException(status_code=400, detail="Report text cannot be empty.")

    try:
        # Send the report text to the Hugging Face API for simplification
        simplified_report = send_to_huggingface_api([
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": report_text}
        ])

        # Generate a new session ID
        session_id = generate_session_id()

        # Store the report and initialize session history
        user_sessions[session_id] = {
            "medical_report": report_text,
            "history": []  # Stores previous user queries and bot responses
        }

        return {"session_id": session_id, "simplified_report": simplified_report}
    except HTTPException as http_exc:
        logger.error(f"HTTP exception in simplify_report: {http_exc.detail}")
        raise http_exc
    except Exception as e:
        logger.error(f"Unexpected error in simplify_report: {e}")
        raise HTTPException(status_code=500, detail=f"Error simplifying report: {str(e)}")


def handle_user_question(session_id: str, question: str) -> str:
    """
    Handles user queries related to the uploaded medical report.

    Args:
        session_id (str): The session ID associated with the user's report.
        question (str): The user's question about the report.

    Returns:
        str: The response to the user's question.

    Raises:
        HTTPException: If the session is not found or there is an error handling the question.
    """
    if not session_id or not question:
        logger.error("Invalid session ID or question provided.")
        raise HTTPException(status_code=400, detail="Session ID and question cannot be empty.")

    if session_id not in user_sessions:
        logger.error(f"Session not found: {session_id}")
        raise HTTPException(status_code=404, detail="Session not found.")

    # Fetch session data
    session_data = user_sessions[session_id]
    history: List[Dict[str, str]] = session_data["history"]

    # Build the prompt for Hugging Face API
    if not history:
        # First question: Include the medical report and question
        prompt = f"""
Here is the medical report:
{session_data["medical_report"]}

Question: {question}
"""
    else:
        # Subsequent questions: Only include the conversation history
        history_context = "\n".join([f"Q: {h['question']}\nA: {h['answer']}" for h in history])
        prompt = f"""
Conversation so far:
{history_context}

Question: {question}
"""

    try:
        # Get response from Hugging Face API
        response = send_to_huggingface_api([
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": prompt}
        ])

        # Save question and answer in the session history
        session_data["history"].append({
            "question": question,
            "answer": response
        })

        return response
    except HTTPException as http_exc:
        logger.error(f"HTTP exception in handle_user_question: {http_exc.detail}")
        raise http_exc
    except Exception as e:
        logger.error(f"Unexpected error in handle_user_question: {e}")
        raise HTTPException(status_code=500, detail=f"Error handling question: {str(e)}")


def end_session(session_id: str) -> Dict[str, str]:
    """
    Ends a session and removes associated data.

    Args:
        session_id (str): The session ID to end.

    Returns:
        Dict[str, str]: A confirmation message.

    Raises:
        HTTPException: If the session is not found.
    """
    if not session_id:
        logger.error("Invalid session ID provided.")
        raise HTTPException(status_code=400, detail="Session ID cannot be empty.")

    if session_id not in user_sessions:
        logger.error(f"Session not found: {session_id}")
        raise HTTPException(status_code=404, detail="Session not found.")

    # Remove the session data
    del user_sessions[session_id]
    return {"message": "Session ended and data cleared successfully."}